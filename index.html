<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero Raiz Cuadrada</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-canvas: #FFFFFF;
            --ui-white: #FFFFFF;
            --ui-gray-light: #F2F2F2;
            --ui-gray-med: #CCCCCC;
            --ui-gray-dark: #888888;
            --text-main: #222222;
        }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: 'Inter', sans-serif; background: var(--ui-gray-light); }

        header {
            position: absolute; top: 15px; left: 20px; z-index: 100;
            display: flex; align-items: baseline; gap: 10px; pointer-events: none;
        }
        header h1 { font-family: 'Playfair Display', serif; font-size: 28px; margin: 0; color: var(--text-main); }
        header span { font-family: 'Playfair Display', serif; font-size: 16px; color: var(--ui-gray-dark); font-weight: bold; }

        /* --- LIBRER√çA INFERIOR DERECHA --- */
        .symbol-library {
            position: absolute; bottom: 90px; right: 20px; width: 380px;
            background: var(--ui-white); border-radius: 12px; padding: 12px;
            border: 1px solid var(--ui-gray-med); box-shadow: 0 4px 15px rgba(0,0,0,0.1); z-index: 1000;
        }
        .pill-container {
            display: flex; gap: 6px; overflow-x: auto; padding-bottom: 8px;
            scrollbar-width: thin; scrollbar-color: var(--ui-gray-med) transparent;
            border-bottom: 1px solid var(--ui-gray-light);
        }
        .symbol-grid {
            display: flex; gap: 8px; overflow-x: auto; padding: 10px 0;
            scrollbar-width: thin; scrollbar-color: var(--ui-gray-med) transparent;
        }
        .pill {
            padding: 5px 12px; background: var(--ui-gray-light); border-radius: 15px;
            font-size: 11px; font-weight: 600; cursor: pointer; white-space: nowrap;
            transition: 0.2s; border: none; color: var(--ui-gray-dark);
        }
        .pill.active { background: var(--text-main); color: var(--ui-white); }
        .symbol-btn {
            background: white; border: 1px solid var(--ui-gray-med); border-radius: 8px;
            min-width: 50px; height: 50px; cursor: pointer; display: flex;
            align-items: center; justify-content: center; flex-shrink: 0;
        }

        /* --- TABLERO --- */
        #board-container { width: 100vw; height: 100vh; position: relative; background: var(--bg-canvas); }
        svg { width: 100%; height: 100%; }

        /* Elementos Manipulables */
        .draggable-item {
            position: absolute; cursor: move; padding: 10px;
            transform-origin: top left; user-select: none;
        }
        .draggable-item.selected { outline: 1px solid var(--ui-gray-med); }
        
        /* Flecha de expansi√≥n (Manija) */
        .resize-handle {
            position: absolute; bottom: -5px; right: -5px; width: 15px; height: 15px;
            background: var(--ui-gray-dark); clip-path: polygon(100% 0, 100% 100%, 0 100%);
            cursor: nwse-resize; display: none;
        }
        .draggable-item.selected .resize-handle { display: block; }

        .sketch-path, .polyline-path {
            fill: none; stroke: var(--text-main); stroke-width: 3;
            stroke-linecap: round; stroke-linejoin: round; cursor: move;
            transform-origin: center;
        }

        /* --- TOOLBAR --- */
        .toolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--ui-white); padding: 8px 15px; border-radius: 50px;
            display: flex; gap: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid var(--ui-gray-med); z-index: 100;
        }
        .tool-btn {
            border: 1px solid transparent; background: none; font-size: 13px;
            cursor: pointer; padding: 8px 12px; border-radius: 10px;
            color: var(--ui-gray-dark); font-weight: 600;
        }
        .tool-btn.active { background: var(--ui-gray-light); color: var(--text-main); border-color: var(--ui-gray-med); }
        .divider { width: 1px; background: var(--ui-gray-med); margin: 0 5px; }
/* --- ESTILOS DE SELECCI√ìN (SOLO GRISES) --- */

    /* El recuadro gris transparente que dibujas con el mouse */
    .selection-box {
        fill: rgba(136, 136, 136, 0.15); /* Gris muy clarito */
        stroke: #888888;               /* Borde gris medio */
        stroke-width: 1;
        stroke-dasharray: 4;           /* Borde punteado */
        pointer-events: none;
    }

    /* Lo que pasa cuando seleccionas un objeto (L√°piz, Figuras o LaTeX) */
    .selected {
        outline: 2px solid #222222 !important; /* Borde negro/gris oscuro resaltado */
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.2);
    }

    /* Limpieza de los bordes de LaTeX: solo se ven si pasas el mouse o seleccionas */
    .draggable-item {
        border: 1px dashed transparent !important; 
        transition: border 0.2s;
    }
    .draggable-item:hover, .draggable-item.selected {
        border: 1px dashed #888888 !important; 
    }


        

    </style>



    
</head>
<body>

<header>
    <h1>Tablero</h1>
    <span>‚àö(Raiz) Cuadrada¬≤</span>
</header>

<div class="symbol-library">
    <div class="pill-container" id="category-pills"></div>
    <div class="symbol-grid" id="symbol-display"></div>
</div>

<div class="toolbar">
    <button class="tool-btn active" onclick="setMode('DRAW')"> üñâ L√°piz</button>
    <button class="tool-btn" onclick="setMode('POLY')"> ñ°¨ Polil√≠nea</button>
    <button class="tool-btn" onclick="setMode('ERASE')"> ‚úÑ Borrador</button>
    <div class="divider"></div>
    <button class="tool-btn" onclick="promptLatex()">‚àë Escribir en LaTeX</button>
    <button class="tool-btn" onclick="setMode('RECT')"> ‚ñ¢ Rect√°ngulo</button>
<button class="tool-btn" onclick="setMode('CIRCLE')">‚óØ C√≠rculo</button>
<button class="tool-btn" onclick="setMode('TRI')">‚ñ≥ Tri√°ngulo</button>
    <button class="tool-btn" onclick="clearBoard()"> ‚®Ø Limpiar</button>
    <button class="tool-btn" onclick="exportPNG()"> ‚á™ PNG</button>
    <button class="tool-btn" id="btn-select" onclick="setMode('SELECT')">‚¨ö Seleccionar</button>
</div>

<div id="board-container">
    <svg id="svg-canvas"></svg>
    <div id="latex-layer"></div>
</div>

    

<script>

    let mode = 'DRAW';
    let isDrawing = false;
    let startX, startY;        // Solo una vez aqu√≠
    let currentPath = null;
    let polyPoints = [];
    let selectedElements = []; // Lista para el grupo
    let selectionRect = null;  // El recuadro visual

    const svg = document.getElementById('svg-canvas');
    const latexLayer = document.getElementById('latex-layer');
    const symbolDisplay = document.getElementById('symbol-display');
    const categoryPills = document.getElementById('category-pills');

    // --- CONFIGURACI√ìN DE LIBRER√çA (Exactamente tus categor√≠as) ---
    const library = {
        "Letras Griegas": [{ s: "\\alpha" }], "Flechas": [{ s: "\\rightarrow" }],
        "L√≥gica": [{ s: "\\forall" }], "Principales": [{ s: "\\sum" }],
        "Desigualdades": [{ s: "\\geq" }], "C√°lculo": [{ s: "\\int" }],
        "Conjuntos": [{ s: "\\in" }], "Matrices/Sist": [{ s: "\\begin{pmatrix} a & b \\end{pmatrix}" }],
        "Par√©ntesis": [{ s: "\\left( x \\right)" }], "Otros": [{ s: "\\infty" }]
    };

    // Renderizado UI Librer√≠a
    Object.keys(library).forEach((cat, i) => {
        const btn = document.createElement('button');
        btn.className = `pill ${i === 0 ? 'active' : ''}`;
        btn.innerText = cat;
        btn.onclick = (e) => {
            document.querySelectorAll('.pill').forEach(p => p.classList.remove('active'));
            btn.classList.add('active');
            renderSymbols(cat);
        };
        categoryPills.appendChild(btn);
    });

    function renderSymbols(cat) {
        symbolDisplay.innerHTML = '';
        library[cat].forEach(item => {
            const b = document.createElement('div');
            b.className = 'symbol-btn';
            symbolDisplay.appendChild(b);
            katex.render(item.s, b);
            b.onclick = () => addLatexItem(item.s);
        });
    }
    renderSymbols("Letras Griegas");

    

    // --- FUNCIONES DE MODO ---

    
    function setMode(m) {
        mode = m;
        polyPoints = []; // Reset polil√≠nea al cambiar
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        event.currentTarget.classList.add('active');
        svg.style.cursor = (m === 'DRAW' || m === 'POLY') ? 'crosshair' : 'default';
    }
    

    // --- MANEJO DE EVENTOS --- LOS MOUSE


    
 svg.onmousedown = (e) => {
    const rect = svg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Guardamos el punto inicial para los c√°lculos de RECT, CIRCLE y TRI
    startX = x; 
    startY = y;

    if (mode === 'DRAW') {
        isDrawing = true;
        currentPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        currentPath.setAttribute("class", "sketch-path"); // Clase para que el borrador lo detecte
        currentPath.setAttribute("d", `M ${x} ${y}`);
        currentPath.setAttribute("transform", "translate(0,0) scale(1)"); // Para que se pueda escalar
        currentPath.setAttribute("stroke", "var(--text-main)"); // Color gris/negro del tema
        svg.appendChild(currentPath);
    } else if (mode === 'POLY') {
        if (polyPoints.length === 0) {
            currentPath = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
            currentPath.setAttribute("class", "sketch-path");
            currentPath.setAttribute("points", `${x},${y}`);
            currentPath.setAttribute("transform", "translate(0,0) scale(1)");
            currentPath.setAttribute("stroke", "var(--text-main)");
            currentPath.setAttribute("fill", "none");
            currentPath.setAttribute("stroke-width", "3");
            svg.appendChild(currentPath);
        }
        polyPoints.push(`${x},${y}`);
        currentPath.setAttribute("points", polyPoints.join(' '));
    } else if (mode === 'RECT') {
        isDrawing = true; // Activar arrastre
        currentPath = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        currentPath.setAttribute("class", "sketch-path");
        currentPath.setAttribute("x", x);
        currentPath.setAttribute("y", y);
        currentPath.setAttribute("fill", "none");
        currentPath.setAttribute("stroke", "var(--text-main)");
        currentPath.setAttribute("stroke-width", "3");
        currentPath.setAttribute("transform", "translate(0,0) scale(1)");
        svg.appendChild(currentPath);
    } else if (mode === 'CIRCLE') {
        isDrawing = true;
        currentPath = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        currentPath.setAttribute("class", "sketch-path");
        currentPath.setAttribute("cx", x);
        currentPath.setAttribute("cy", y);
        currentPath.setAttribute("fill", "none");
        currentPath.setAttribute("stroke", "var(--text-main)");
        currentPath.setAttribute("stroke-width", "3");
        currentPath.setAttribute("transform", "translate(0,0) scale(1)");
        svg.appendChild(currentPath);
    } else if (mode === 'TRI') {
        isDrawing = true;
        currentPath = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        currentPath.setAttribute("class", "sketch-path");
        currentPath.setAttribute("fill", "none");
        currentPath.setAttribute("stroke", "var(--text-main)");
        currentPath.setAttribute("stroke-width", "3");
        currentPath.setAttribute("transform", "translate(0,0) scale(1)");
        svg.appendChild(currentPath);
    }
     if (mode === 'SELECT') {
    deselectAll(); // Limpiar selecci√≥n previa
    
    selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    selectionRect.setAttribute("class", "selection-box");
    selectionRect.setAttribute("x", x);
    selectionRect.setAttribute("y", y);
    svg.appendChild(selectionRect);
    
    startX = x;
    startY = y;
    isDrawing = true;
}
};

   svg.onmousemove = (e) => {
    // 1. Verificaci√≥n b√°sica: ¬øEstamos dibujando algo?
    if (!isDrawing || (!currentPath && !selectionRect)) return;

    const rect = svg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // 2. L√≥gica para el L√°piz (DRAW)
    if (mode === 'DRAW') {
        const d = currentPath.getAttribute("d");
        currentPath.setAttribute("d", `${d} L ${x} ${y}`);
    } 
    
    // 3. L√≥gica para el Rect√°ngulo
    else if (mode === 'RECT') {
        let width = x - startX;
        let height = y - startY;
        currentPath.setAttribute("width", Math.abs(width));
        currentPath.setAttribute("height", Math.abs(height));
        // Si arrastras hacia la izquierda o arriba, ajustamos la posici√≥n
        if(width < 0) currentPath.setAttribute("x", x);
        else currentPath.setAttribute("x", startX);
        
        if(height < 0) currentPath.setAttribute("y", y);
        else currentPath.setAttribute("y", startY);
    } 
    
    // 4. L√≥gica para el C√≠rculo
    else if (mode === 'CIRCLE') {
        // Calculamos la distancia entre el centro y el mouse para el radio
        let radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
        currentPath.setAttribute("r", radius);
    } 
    
    // 5. L√≥gica para el Tri√°ngulo
    else if (mode === 'TRI') {
        // Punto 1: Cima (startX, startY)
        // Punto 2: Esquina derecha (x, y)
        // Punto 3: Esquina izquierda (espejo de la derecha)
        let points = `${startX},${startY} ${x},${y} ${startX - (x - startX)},${y}`;
        currentPath.setAttribute("points", points);
    }
       if (mode === 'SELECT' && isDrawing && selectionRect) {
    let width = x - startX;
    let height = y - startY;
    
    selectionRect.setAttribute("width", Math.abs(width));
    selectionRect.setAttribute("height", Math.abs(height));
    selectionRect.setAttribute("x", width < 0 ? x : startX);
    selectionRect.setAttribute("y", height < 0 ? y : startY);
}
};

   svg.ondblclick = (e) => {
    // 1. Si est√°s terminando una polil√≠nea
    if (mode === 'POLY' && currentPath) {
        makeMovable(currentPath, 'path');
        polyPoints = [];
        currentPath = null;
    }

    // 2. Si haces doble clic en el FONDO (para limpiar selecci√≥n y bordes)
    // Usamos e.target para saber si tocaste el lienzo vac√≠o o un objeto
    if (e.target === svg || e.target.id === 'latex-layer') {
        deselectAll(); // Esta es la funci√≥n que borra los bordes grises y la lista
    }
};

window.onmouseup = () => {
    // 1. L√≥gica para terminar la SELECCI√ìN (La red de pesca)
    if (mode === 'SELECT' && selectionRect) {
        const box = selectionRect.getBoundingClientRect();
        // Buscamos dibujos SVG (.sketch-path) y cajas LaTeX (.draggable-item)
        const items = document.querySelectorAll('.sketch-path, .draggable-item');
        
        items.forEach(item => {
            const itemRect = item.getBoundingClientRect();
            // Verificamos si hay colisi√≥n (si el objeto est√° dentro del cuadro gris)
            const isInside = !(itemRect.left > box.right || 
                               itemRect.right < box.left || 
                               itemRect.top > box.bottom || 
                               itemRect.bottom < box.top);
            
            if (isInside) {
                item.classList.add('selected'); // Se ilumina el borde
                selectedElements.push(item);    // Se guarda en la lista de grupo
            }
        });

        selectionRect.remove(); // Borramos el cuadro gris visual
        selectionRect = null;
    }

    // 2. Tu l√≥gica original para DIBUJO y FIGURAS
    if (isDrawing && currentPath) {
        // A√±adimos "mode !== 'SELECT'" para que no intente procesar el cuadro gris como dibujo
        if (mode !== 'POLY' && mode !== 'SELECT') {
            makeMovable(currentPath, 'path'); 
            currentPath = null; 
        }
    }
    
    isDrawing = false;
};
    
    // --- GESTI√ìN DE LATEX ---

    
    function promptLatex() {
        const code = prompt("Escribe tu c√≥digo LaTeX:", "\\sqrt{x^2 + y^2}");
        if (code) addLatexItem(code);
    }

    function addLatexItem(tex) {
        const wrapper = document.createElement('div');
        wrapper.className = 'draggable-item';
        wrapper.style.left = '100px';
        wrapper.style.top = '100px';
        wrapper.style.transform = "scale(1)";
        wrapper.dataset.tex = tex;

        const content = document.createElement('div');
        const handle = document.createElement('div');
        handle.className = 'resize-handle';
        
        wrapper.appendChild(content);
        wrapper.appendChild(handle);
        latexLayer.appendChild(wrapper);
        
        katex.render(tex, content);

        wrapper.ondblclick = (e) => {
            e.stopPropagation();
            const newTex = prompt("Editar LaTeX:", wrapper.dataset.tex);
            if (newTex) {
                wrapper.dataset.tex = newTex;
                katex.render(newTex, content);
            }
        };



        makeMovable(wrapper, 'div');
        makeManualResize(wrapper, handle);
    }
    

    // --- MOVIMIENTO, ESCALADO Y BORRADO ---

// --- SISTEMA DE MOVIMIENTO, ESCALADO Y BORRADO UNIFICADO ---

function makeMovable(el, type) {
    let dragging = false;
    let initialX, initialY;

    el.addEventListener('mousedown', (e) => {
        if (mode === 'ERASE') {
            el.remove();
            selectedElements = selectedElements.filter(item => item !== el);
            return;
        }

        // Selecci√≥n autom√°tica al hacer clic
        if (mode === 'SELECT' || mode === 'DRAW') {
            if (!el.classList.contains('selected')) {
                deselectAll();
                el.classList.add('selected');
                selectedElements = [el];
            }
        }

        e.stopPropagation();
        dragging = true;
        initialX = e.clientX;
        initialY = e.clientY;
    });

    window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        
        let dx = e.clientX - initialX;
        let dy = e.clientY - initialY;

        if (el.classList.contains('selected')) {
            // Mover todos los seleccionados en grupo
            selectedElements.forEach(item => moverElementoIndividual(item, dx, dy));
        } else {
            // Mover solo este si no est√° en un grupo
            moverElementoIndividual(el, dx, dy);
        }

        initialX = e.clientX;
        initialY = e.clientY;
    });

    window.addEventListener('mouseup', () => {
        dragging = false;
    });

    // --- ESCALADO CON RUEDA ---
    el.addEventListener('wheel', (e) => {
        e.preventDefault();
        let scale;
        
        if (type === 'path') {
            const t = el.getAttribute("transform") || "translate(0,0) scale(1)";
            const match = t.match(/scale\(([^)]+)\)/);
            scale = match ? parseFloat(match[1]) : 1;
            scale += e.deltaY * -0.001;
            el.setAttribute("transform", t.replace(/scale\([^)]+\)/, `scale(${Math.max(0.1, scale)})`));
        } else {
            const t = el.style.transform || "scale(1)";
            const match = t.match(/scale\(([^)]+)\)/);
            scale = match ? parseFloat(match[1]) : 1;
            scale += e.deltaY * -0.001;
            el.style.transform = `scale(${Math.max(0.1, scale)})`;
        }
    }, { passive: false });
}

// Funci√≥n auxiliar para aplicar el movimiento real
function moverElementoIndividual(item, dx, dy) {
    if (item.tagName.toLowerCase() === 'div') {
        // Mover LaTeX (HTML)
        let x = parseFloat(item.style.left) || 0;
        let y = parseFloat(item.style.top) || 0;
        item.style.left = (x + dx) + "px";
        item.style.top = (y + dy) + "px";
    } else {
        // Mover Figuras/L√°piz (SVG)
        let transform = item.getAttribute("transform") || "translate(0,0) scale(1)";
        
        // Usamos Regex para capturar translate(x, y) de forma segura
        let translateMatch = transform.match(/translate\(([^,)]+),? ?([^)]+)\)/);
        let tx = 0, ty = 0;
        
        if (translateMatch) {
            tx = parseFloat(translateMatch[1]);
            ty = parseFloat(translateMatch[2]);
        }

        let newTx = tx + dx;
        let newTy = ty + dy;

        // Mantener la escala que ya ten√≠a
        let scalePart = transform.includes("scale") ? transform.match(/scale\([^)]+\)/)[0] : "scale(1)";
        
        item.setAttribute("transform", `translate(${newTx},${newTy}) ${scalePart}`);
    }
}

   function makeManualResize(el, handle) {
    let resizing = false;

    handle.onmousedown = (e) => {
        e.stopPropagation();
        e.preventDefault();
        resizing = true;
    };

    document.addEventListener('mousemove', (e) => {
        if (!resizing) return;
        
        // Obtenemos la escala actual del elemento
        const t = el.style.transform || "scale(1)";
        const match = t.match(/scale\(([^)]+)\)/);
        let scale = match ? parseFloat(match[1]) : 1;

        // Ajustamos la escala seg√∫n el movimiento del mouse (sensibilidad 0.01)
        scale += 0.01 * (e.movementX + e.movementY);
        
        // Aplicamos la nueva escala con un m√≠nimo de 0.2
        el.style.transform = `scale(${Math.max(0.2, scale)})`;
    });

    document.addEventListener('mouseup', () => {
        resizing = false;
    });
}

    function clearBoard() { 
    if(confirm("¬øLimpiar todo?")) { 
        svg.innerHTML = ''; 
        latexLayer.innerHTML = ''; 
        selectedElements = []; // A√±ade esta l√≠nea para resetear la memoria
    } 
}

    // --- FUNCI√ìN DE EXPORTACI√ìN ---
    async function exportPNG() {
        const canvas = await html2canvas(document.getElementById('board-container'));
        const link = document.createElement('a');
        link.download = 'tablero.png';
        link.href = canvas.toDataURL();
        link.click();
    }

    // --- FUNCI√ìN DE LIMPIEZA ---
    function deselectAll() {
        // 1. Quita el borde visual de todos los elementos
        document.querySelectorAll('.selected').forEach(el => {
            el.classList.remove('selected');
        });
        // 2. Vac√≠a la lista en la memoria del programa
        selectedElements = [];
    }

    // --- ESCUCHADORES GLOBALES (FUERA DE LAS FUNCIONES) ---
    
    // Detectan el doble clic en el lienzo SVG
    svg.addEventListener('dblclick', (e) => {
        if (e.target === svg) deselectAll();
    });

    // Detectan el doble clic en la capa de LaTeX
    latexLayer.addEventListener('dblclick', (e) => {
        if (e.target === latexLayer) deselectAll();
    });
    
    
</script>
</body>
</html>
