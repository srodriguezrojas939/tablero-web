
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero Pro - Raiz Cuadrada</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">

    <style>
        /* ============================================================
           ESTILOS GENERALES Y VARIABLES
           ============================================================ */
        :root {
            --bg-canvas: #FFFFFF;
            --ui-white: #FFFFFF;
            --ui-gray-light: #F2F2F2;
            --ui-gray-med: #CCCCCC;
            --ui-gray-dark: #888888;
            --text-main: #222222;
            --accent: #4A90E2;
        }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: 'Inter', sans-serif; background: var(--ui-gray-light); }

        /* --- CABECERA --- */
        header {
            position: absolute; top: 15px; left: 20px; z-index: 100;
            display: flex; align-items: baseline; gap: 10px; pointer-events: none;
        }
        header h1 { font-family: 'Playfair Display', serif; font-size: 28px; margin: 0; color: var(--text-main); }
        header span { font-family: 'Playfair Display', serif; font-size: 16px; color: var(--ui-gray-dark); font-weight: bold; }

        /* --- LIBRER√çA DE S√çMBOLOS --- */
        .symbol-library {
            position: absolute; bottom: 90px; right: 20px; width: 300px;
            background: var(--ui-white); border-radius: 12px; padding: 12px;
            border: 1px solid var(--ui-gray-med); box-shadow: 0 4px 15px rgba(0,0,0,0.1); z-index: 1000;
        }
        .pill-container { display: flex; gap: 6px; overflow-x: auto; padding-bottom: 8px; border-bottom: 1px solid var(--ui-gray-light); }
        .symbol-grid { display: flex; gap: 8px; overflow-x: auto; padding: 10px 0; }
        .pill { padding: 5px 12px; background: var(--ui-gray-light); border-radius: 15px; font-size: 11px; font-weight: 600; cursor: pointer; border: none; color: var(--ui-gray-dark); white-space: nowrap; }
        .pill.active { background: var(--text-main); color: var(--ui-white); }
        .symbol-btn { background: white; border: 1px solid var(--ui-gray-med); border-radius: 8px; min-width: 50px; height: 50px; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }

        /* --- EDITOR DE LATEX --- */
        #editor-panel {
            position: absolute; bottom: 90px; left: 50%; transform: translateX(-50%);
            background: white; padding: 15px; border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15); border: 1px solid var(--ui-gray-med);
            display: none; z-index: 2000; flex-direction: column; gap: 10px; width: 300px;
        }
        #editor-panel input { padding: 10px; border: 1px solid var(--ui-gray-med); border-radius: 8px; font-family: monospace; }
        .editor-btns { display: flex; gap: 8px; }
        .editor-btns button { flex: 1; padding: 8px; border-radius: 6px; border: none; cursor: pointer; font-weight: 600; }

        /* --- CONTENEDORES DEL TABLERO --- */
        #board-container { width: 100vw; height: 100vh; position: relative; background: var(--bg-canvas); overflow: hidden; }
        svg { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        #latex-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }

        /* --- ELEMENTOS DIBUJADOS Y SELECCI√ìN --- */
        .draggable-item { position: absolute; cursor: move; padding: 10px; transform-origin: top left; pointer-events: auto; border: 1px dashed transparent; }
        .draggable-item.selected { border: 1px dashed var(--accent) !important; background: rgba(74, 144, 226, 0.05); }
        .resize-handle { position: absolute; bottom: 0; right: 0; width: 12px; height: 12px; background: var(--accent); cursor: nwse-resize; display: none; }
        .draggable-item.selected .resize-handle { display: block; }

        .sketch-path { fill: none; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round; cursor: move; pointer-events: auto; }
        .sketch-path.selected { stroke: var(--accent); filter: drop-shadow(0 0 3px rgba(74, 144, 226, 0.5)); }

        .selection-box { fill: rgba(74, 144, 226, 0.1); stroke: var(--accent); stroke-width: 1; stroke-dasharray: 4; pointer-events: none; }

        /* --- BARRA DE HERRAMIENTAS --- */
        .toolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--ui-white); padding: 8px 15px; border-radius: 50px;
            display: flex; gap: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid var(--ui-gray-med); z-index: 1000;
        }
        .tool-btn { border: 1px solid transparent; background: none; font-size: 13px; cursor: pointer; padding: 8px 12px; border-radius: 10px; color: var(--ui-gray-dark); font-weight: 600; }
        .tool-btn.active { background: var(--ui-gray-light); color: var(--text-main); border-color: var(--ui-gray-med); }
        .divider { width: 1px; background: var(--ui-gray-med); margin: 0 5px; }

        /* Estilo para la grilla activada: L√≠neas continuas + Puntos en intersecciones */
.grid-active {
    background-image:
        /* Capa 1 (Arriba): Puntos grises en las intersecciones */
        radial-gradient(var(--ui-gray-dark) 1.5px, transparent 1.5px),
        /* Capa 2: L√≠neas verticales sutiles */
        linear-gradient(to right, var(--ui-gray-med) 1px, transparent 1px),
        /* Capa 3 (Abajo): L√≠neas horizontales sutiles */
        linear-gradient(to bottom, var(--ui-gray-med) 1px, transparent 1px);
    /* El tama√±o (20px) debe coincidir con la variable gridStep del JS */
    background-size: 20px 20px;
    /* Un peque√±o ajuste para alinear perfectamente puntos y l√≠neas */
    background-position: -1px -1px;
}
        
    </style>
</head>
<body>

<header>
    <h1>Tablero</h1>
    <span>‚àö(Raiz) Cuadrada¬≤</span>
</header>

<div id="editor-panel">
    <strong id="editor-title" style="font-size: 12px; color: var(--ui-gray-dark);">EDITAR LATEX</strong>
    <input type="text" id="latex-input" placeholder="Escribe aqu√≠...">
    <div class="editor-btns">
        <button onclick="confirmEdit()" style="background: var(--text-main); color: white;">Aplicar</button>
        <button onclick="closeEditor()" style="background: var(--ui-gray-light);">Cancelar</button>
    </div>
</div>

<div class="symbol-library">
    <div class="pill-container" id="category-pills"></div>
    <div class="symbol-grid" id="symbol-display"></div>
</div>

<div class="toolbar">
    <button class="tool-btn" onclick="undo()">‚Ü∂</button>
    <button class="tool-btn" onclick="redo()">‚Ü∑</button>
    <div class="divider"></div>
    <button class="tool-btn active" onclick="setMode('DRAW', this)">üñâ L√°piz</button>
    <button class="tool-btn" onclick="setMode('POLY', this)">ñ°¨ Polil√≠nea</button>
    <button class="tool-btn" onclick="setMode('ERASE', this)">‚úÑ</button>
    <button class="tool-btn" onclick="setMode('SELECT', this)">‚¨ö</button>
    <div class="divider"></div>
    <button class="tool-btn" onclick="openEditorForNew()">‚àë LaTeX</button>
    <button class="tool-btn" onclick="setMode('RECT', this)">‚ñ¢</button>
    <button class="tool-btn" onclick="setMode('CIRCLE', this)">‚óØ</button>
    <div class="divider"></div>
    <button class="tool-btn" onclick="clearBoard()">‚®Ø</button>
    <button class="tool-btn" onclick="exportPNG()">‚á™ PNG</button>
    <button id="grid-btn" class="tool-btn" onclick="toggleGrid()"># Grilla</button>
</div>

<div id="board-container">
    <svg id="svg-canvas"></svg>
    <div id="latex-layer"></div>
</div>

<script>
    /* ============================================================
       1. VARIABLES GLOBALES Y ESTADO
       ============================================================ */
    let mode = 'DRAW', isDrawing = false, startX, startY;
    let currentPath = null, polyPoints = [], selectedElements = [], selectionRect = null;
    let undoStack = [], redoStack = [], editingItem = null;
    let clipboard = []; // Memoria para Ctrl+C y Ctrl+V

    const svg = document.getElementById('svg-canvas');
    const latexLayer = document.getElementById('latex-layer');
    const editorPanel = document.getElementById('editor-panel');
    const latexInput = document.getElementById('latex-input');
    let snapEnabled = false;
const gridStep = 20; // Tama√±o de la cuadr√≠cula

    /* ============================================================
       2. LIBRER√çA DE S√çMBOLOS (KATEX)
       ============================================================ */
    const library = {
        "Griegas": [{ s: "\\alpha" }, { s: "\\beta" }, { s: "\\gamma" }, { s: "\\theta" }],
        "C√°lculo": [{ s: "\\int_{a}^{b}" }, { s: "\\frac{df}{dx}" }, { s: "\\lim_{x \\to \\infty}" }],
        "√Ålgebra": [{ s: "\\sqrt{x^2 + y^2}" }, { s: "x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}" }],
        "Matrices": [{ s: "\\begin{matrix} 1 & 0 \\\\ 0 & 1 \\end{matrix}" }]
    };

    function initLibrary() {
        const container = document.getElementById('category-pills');
        Object.keys(library).forEach((cat, i) => {
            const btn = document.createElement('button');
            btn.className = `pill ${i === 0 ? 'active' : ''}`;
            btn.innerText = cat;
            btn.onclick = () => {
                document.querySelectorAll('.pill').forEach(p => p.classList.remove('active'));
                btn.classList.add('active');
                renderSymbols(cat);
            };
            container.appendChild(btn);
        });
        renderSymbols(Object.keys(library)[0]);
        saveState();
    }

    function renderSymbols(cat) {
        const grid = document.getElementById('symbol-display');
        grid.innerHTML = '';
        library[cat].forEach(item => {
            const b = document.createElement('div');
            b.className = 'symbol-btn';
            katex.render(item.s, b);
            b.onclick = () => addLatexItem(item.s);
            grid.appendChild(b);
        });
    }

    /* ============================================================
       3. GESTI√ìN DE MODOS Y HERRAMIENTAS
       ============================================================ */
    function setMode(m, btn) {
        mode = m; 
        polyPoints = []; 
        if(currentPath && m !== 'POLY') currentPath.remove();
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        if(btn) btn.classList.add('active');
    }

    /* ============================================================
       4. L√ìGICA DE DIBUJO Y MOUSE
       ============================================================ */
    svg.onmousedown = (e) => {
        const x = snap(e.offsetX), y = snap(e.offsetY);
        startX = x; startY = y;

        if (mode === 'SELECT') { 
            deselectAll(); 
            isDrawing = true; 
            selectionRect = createSVGElement('rect', {class: 'selection-box'}); 
            svg.appendChild(selectionRect); 
            return; 
        }
        
        if (mode === 'POLY') {
            if (polyPoints.length === 0) {
                currentPath = createSVGElement('polyline', {class: 'sketch-path', stroke: 'var(--text-main)', fill: 'none', transform: 'translate(0,0) scale(1)'});
                svg.appendChild(currentPath);
            }
            polyPoints.push(`${x},${y}`);
            currentPath.setAttribute('points', polyPoints.join(' '));
            return;
        }

        isDrawing = true;
        if (mode === 'DRAW') currentPath = createSVGElement('path', {d: `M ${x} ${y}`});
        else if (mode === 'RECT') currentPath = createSVGElement('rect', {x, y, width:0, height:0});
        else if (mode === 'CIRCLE') currentPath = createSVGElement('circle', {cx:x, cy:y, r:0});

        if (currentPath) {
            Object.assign(currentPath.style, { stroke: 'var(--text-main)', fill: 'none', strokeWidth: '3' });
            currentPath.setAttribute('class', 'sketch-path');
            currentPath.setAttribute('transform', 'translate(0,0) scale(1)');
            svg.appendChild(currentPath);
        }
    };

    svg.onmousemove = (e) => {
        if (!isDrawing && mode !== 'POLY') return;
        const x = snap(e.offsetX), y = snap(e.offsetY);

        if (selectionRect) {
            let w = x - startX, h = y - startY;
            selectionRect.setAttribute('width', Math.abs(w)); selectionRect.setAttribute('height', Math.abs(h));
            selectionRect.setAttribute('x', w < 0 ? x : startX); selectionRect.setAttribute('y', h < 0 ? y : startY);
        } else if (currentPath) {
            if (mode === 'DRAW') currentPath.setAttribute('d', currentPath.getAttribute('d') + ` L ${x} ${y}`);
            else if (mode === 'RECT') {
                currentPath.setAttribute('width', Math.abs(x - startX)); currentPath.setAttribute('height', Math.abs(y - startY));
                currentPath.setAttribute('x', Math.min(x, startX)); currentPath.setAttribute('y', Math.min(y, startY));
            } else if (mode === 'CIRCLE') {
                currentPath.setAttribute('r', Math.sqrt((x-startX)**2 + (y-startY)**2));
            } else if (mode === 'POLY') {
                let tempPoints = [...polyPoints, `${x},${y}`].join(' ');
                currentPath.setAttribute('points', tempPoints);
            }
        }
    };

    window.onmouseup = () => {
        if (selectionRect) {
            const box = selectionRect.getBoundingClientRect();
            document.querySelectorAll('.sketch-path, .draggable-item').forEach(el => {
                const r = el.getBoundingClientRect();
                if (!(r.left > box.right || r.right < box.left || r.top > box.bottom || r.bottom < box.top)) {
                    el.classList.add('selected'); selectedElements.push(el);
                }
            });
            selectionRect.remove(); selectionRect = null;
        }
        if (isDrawing && currentPath && mode !== 'POLY') { makeMovable(currentPath, 'path'); saveState(); currentPath = null; }
        isDrawing = false;
    };

    svg.ondblclick = () => {
        if (mode === 'POLY' && currentPath) {
            makeMovable(currentPath, 'path'); saveState(); currentPath = null; polyPoints = [];
        }
    };

    /* ============================================================
       5. GESTI√ìN DE TECLADO (BORRAR, COPIAR, PEGAR, UNDO)
       ============================================================ */
    window.onkeydown = (e) => {
        if (document.activeElement.tagName === 'INPUT') return;
        
        // BORRAR
        if (e.key === 'Backspace' || e.key === 'Delete') {
            selectedElements.forEach(el => el.remove());
            selectedElements = [];
            saveState();
        }

        // COPIAR (Ctrl + C)
        if (e.ctrlKey && e.key === 'c') {
            clipboard = selectedElements.map(el => el.cloneNode(true));
        }

        // PEGAR (Ctrl + V)
        if (e.ctrlKey && e.key === 'v') {
            if (clipboard.length === 0) return;
            deselectAll();
            clipboard.forEach(clone => {
                const newEl = clone.cloneNode(true);
                // Desplazamiento visual
                if (newEl.tagName.toLowerCase() === 'div') {
                    newEl.style.left = (parseFloat(newEl.style.left) + 20) + "px";
                    newEl.style.top = (parseFloat(newEl.style.top) + 20) + "px";
                    latexLayer.appendChild(newEl);
                    makeMovable(newEl, 'div');
                    makeManualResize(newEl, newEl.querySelector('.resize-handle'));
                    newEl.ondblclick = (e) => {
                        e.stopPropagation(); editingItem = newEl;
                        latexInput.value = newEl.dataset.tex;
                        editorPanel.style.display = 'flex'; latexInput.focus();
                    };
                } else {
                    let t = newEl.getAttribute("transform") || "translate(0,0) scale(1)";
                    newEl.setAttribute("transform", t.replace(/translate\(([^,)]+),? ?([^)]+)\)/, (m, x, y) => `translate(${parseFloat(x)+20},${parseFloat(y)+20})`));
                    svg.appendChild(newEl);
                    makeMovable(newEl, 'path');
                }
                newEl.classList.add('selected');
                selectedElements.push(newEl);
            });
            saveState();
        }

        // DESHACER (Ctrl + Z)
        if (e.ctrlKey && e.key === 'z') undo();
        // REHACER (Ctrl + Y)
        if (e.ctrlKey && e.key === 'y') redo();
    };

    /* ============================================================
       6. EDITOR DE LATEX INTERNO
       ============================================================ */
    function openEditorForNew() {
        editingItem = null;
        latexInput.value = '';
        editorPanel.style.display = 'flex';
        latexInput.focus();
    }

    function addLatexItem(tex) {
        const wrapper = document.createElement('div');
        wrapper.className = 'draggable-item';
        wrapper.style.left = '100px'; wrapper.style.top = '100px';
        wrapper.style.transform = 'scale(1)';
        wrapper.dataset.tex = tex;
        wrapper.innerHTML = `<div></div><div class="resize-handle"></div>`;
        latexLayer.appendChild(wrapper);
        katex.render(tex, wrapper.querySelector('div'));
        
        wrapper.ondblclick = (e) => {
            e.stopPropagation();
            editingItem = wrapper;
            latexInput.value = wrapper.dataset.tex;
            editorPanel.style.display = 'flex';
            latexInput.focus();
        };

        makeMovable(wrapper, 'div');
        makeManualResize(wrapper, wrapper.querySelector('.resize-handle'));
        saveState();
    }

    function confirmEdit() {
        const val = latexInput.value;
        if (!val) return;
        if (editingItem) {
            editingItem.dataset.tex = val;
            katex.render(val, editingItem.querySelector('div'));
        } else {
            addLatexItem(val);
        }
        closeEditor();
        saveState();
    }

    function closeEditor() { editorPanel.style.display = 'none'; }

    /* ============================================================
       7. UTILIDADES (CREACI√ìN, SELECCI√ìN, MOVIMIENTO)
       ============================================================ */
    function createSVGElement(tag, attrs) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (let k in attrs) el.setAttribute(k, attrs[k]);
        return el;
    }

    function deselectAll() {
        document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
        selectedElements = [];
    }

    function makeMovable(el, type) {
        let dragging = false, iX, iY;
        el.onmousedown = (e) => {
            if (mode === 'ERASE') { el.remove(); saveState(); return; }
            if (!el.classList.contains('selected')) { deselectAll(); el.classList.add('selected'); selectedElements = [el]; }
            e.stopPropagation(); dragging = true; iX = e.clientX; iY = e.clientY;
        };
        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            let dx = snap(e.clientX - iX), dy = snap(e.clientY - iY);
            selectedElements.forEach(item => {
                if (item.tagName.toLowerCase() === 'div') {
                    item.style.left = (parseFloat(item.style.left) + dx) + "px";
                    item.style.top = (parseFloat(item.style.top) + dy) + "px";
                } else {
                    let t = item.getAttribute("transform") || "translate(0,0) scale(1)";
                    let m = t.match(/translate\(([^,)]+),? ?([^)]+)\)/);
                    let tx = parseFloat(m[1]) + dx, ty = parseFloat(m[2]) + dy;
                    item.setAttribute("transform", t.replace(/translate\([^)]+\)/, `translate(${tx},${ty})`));
                }
            });
            iX = e.clientX; iY = e.clientY;
        });
        window.addEventListener('mouseup', () => { if(dragging) { dragging = false; saveState(); } });
    }

    function makeManualResize(el, handle) {
        let resizing = false;
        handle.onmousedown = (e) => { e.stopPropagation(); resizing = true; };
        document.addEventListener('mousemove', (e) => {
            if (!resizing) return;
            let s = parseFloat(el.style.transform.match(/scale\(([^)]+)\)/)[1]);
            s += (e.movementX + e.movementY) * 0.01;
            el.style.transform = `scale(${Math.max(0.2, s)})`;
        });
        document.addEventListener('mouseup', () => { if(resizing) { resizing = false; saveState(); } });
    }

    function toggleGrid() {
    snapEnabled = !snapEnabled;
    const btn = document.getElementById('grid-btn');
    const container = document.getElementById('board-container');
    
    if (snapEnabled) {
        btn.classList.add('active');
        container.classList.add('grid-active');
    } else {
        btn.classList.remove('active');
        container.classList.remove('grid-active');
    }
}

function snap(val) {
    return snapEnabled ? Math.round(val / gridStep) * gridStep : val;
}

    /* ============================================================
       8. HISTORIAL (UNDO/REDO) Y EXPORTACI√ìN
       ============================================================ */
    function saveState() {
        undoStack.push({svg: svg.innerHTML, latex: latexLayer.innerHTML});
        redoStack = []; // Al hacer algo nuevo, se limpia el redo
        if(undoStack.length > 30) undoStack.shift();
    }

    function applyState(state) {
        svg.innerHTML = state.svg; 
        latexLayer.innerHTML = state.latex;
        document.querySelectorAll('.sketch-path').forEach(el => makeMovable(el, 'path'));
        document.querySelectorAll('.draggable-item').forEach(el => {
            makeMovable(el, 'div'); 
            makeManualResize(el, el.querySelector('.resize-handle'));
            el.ondblclick = (e) => {
                e.stopPropagation(); editingItem = el;
                latexInput.value = el.dataset.tex;
                editorPanel.style.display = 'flex'; latexInput.focus();
            };
        });
    }

    function undo() {
        if (undoStack.length < 2) return;
        redoStack.push(undoStack.pop());
        applyState(undoStack[undoStack.length - 1]);
    }
    
    function redo() {
        if (redoStack.length === 0) return;
        const state = redoStack.pop();
        undoStack.push(state);
        applyState(state);
    }

    function clearBoard() { if(confirm("¬øLimpiar todo?")) { svg.innerHTML = ''; latexLayer.innerHTML = ''; saveState(); } }
    
    async function exportPNG() { 
        deselectAll(); 
        const canvas = await html2canvas(document.getElementById('board-container')); 
        const link = document.createElement('a'); 
        link.download = 'tablero.png'; 
        link.href = canvas.toDataURL(); 
        link.click(); 
    }

    // INICIALIZACI√ìN
    initLibrary();
</script>
</body>
</html>
